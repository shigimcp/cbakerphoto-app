import masonryLayout from 'masonry-layout';
import { __decorate, __param } from 'tslib';
import { EventEmitter, Inject, PLATFORM_ID, ElementRef, Input, Output, Component, forwardRef, Renderer2, Directive, NgModule } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { style, animate, AnimationBuilder } from '@angular/animations';

let masonryConstructor;
let NgxMasonryComponent = class NgxMasonryComponent {
    constructor(platformId, _element) {
        this.platformId = platformId;
        this._element = _element;
        this.updateLayout = false;
        // Outputs
        this.layoutComplete = new EventEmitter();
        this.removeComplete = new EventEmitter();
    }
    ngOnInit() {
        if (isPlatformBrowser(this.platformId) && masonryConstructor === undefined) {
            masonryConstructor = masonryLayout;
        }
        // Create masonry options object
        if (!this.options) {
            this.options = {};
        }
        // Set default itemSelector
        if (!this.options.itemSelector) {
            this.options.itemSelector = '[ngxMasonryItem], ngxMasonryItem';
        }
        this.options['transitionDuration'] = '0s';
        if (isPlatformBrowser(this.platformId)) {
            // Initialize Masonry
            this.masonryInstance = new masonryConstructor(this._element.nativeElement, this.options);
            // Bind to events
            this.masonryInstance.on('layoutComplete', (items) => {
                this.layoutComplete.emit(items);
            });
            this.masonryInstance.on('removeComplete', (items) => {
                this.removeComplete.emit(items);
            });
        }
    }
    ngOnChanges(changes) {
        // only update layout if it's not the first change
        if (changes.updateLayout) {
            if (!changes.updateLayout.firstChange) {
                this.layout();
            }
        }
    }
    ngOnDestroy() {
        if (this.masonryInstance) {
            this.masonryInstance.destroy();
        }
    }
    layout() {
        setTimeout(() => {
            this.masonryInstance.layout();
        });
    }
    reloadItems() {
        setTimeout(() => {
            this.masonryInstance.reloadItems();
        });
    }
    // public add(element: HTMLElement, prepend: boolean = false) {
    add(element) {
        // Tell Masonry that a child element has been added
        this.masonryInstance.appended(element);
        // Check if first item
        if (this.masonryInstance.items.length === 1) {
            this.masonryInstance.layout();
        }
    }
    remove(element) {
        // Tell Masonry that a child element has been removed
        this.masonryInstance.remove(element);
        // Layout items
        this.layout();
    }
};
NgxMasonryComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: ElementRef }
];
__decorate([
    Input()
], NgxMasonryComponent.prototype, "options", void 0);
__decorate([
    Input()
], NgxMasonryComponent.prototype, "updateLayout", void 0);
__decorate([
    Output()
], NgxMasonryComponent.prototype, "layoutComplete", void 0);
__decorate([
    Output()
], NgxMasonryComponent.prototype, "removeComplete", void 0);
NgxMasonryComponent = __decorate([
    Component({
        selector: '[ngx-masonry], ngx-masonry',
        template: '<ng-content></ng-content>',
        styles: [`
		:host {
			display: block;
		}
	`]
    }),
    __param(0, Inject(PLATFORM_ID))
], NgxMasonryComponent);

let NgxMasonryDirective = class NgxMasonryDirective {
    constructor(builder, element, parent, renderer) {
        this.builder = builder;
        this.element = element;
        this.parent = parent;
        this.renderer = renderer;
        this.animations = {
            show: [
                style({ opacity: 0 }),
                animate('400ms ease-in', style({ opacity: 1 })),
            ],
            hide: [
                style({ opacity: '*' }),
                animate('400ms ease-in', style({ opacity: 0 })),
            ]
        };
    }
    ngOnInit() {
        if (this.parent.options.animations !== undefined) {
            this.animations = this.parent.options.animations;
        }
    }
    ngAfterViewInit() {
        const images = this.element.nativeElement.getElementsByTagName('img');
        this.renderer.setStyle(this.element.nativeElement, 'opacity', '0');
        this.images = new Set(images);
        if (images.length === 0) {
            this.parent.add(this.element.nativeElement);
        }
        else {
            for (const imageRef of images) {
                this.renderer.listen(imageRef, 'load', _ => {
                    this.imageLoaded(imageRef);
                });
                this.renderer.listen(imageRef, 'error', _ => {
                    this.imageLoaded(imageRef);
                });
            }
        }
    }
    ngOnDestroy() {
        if (this.images.size === 0 && this.element.nativeElement.parentNode) {
            this.playAnimation(false);
            this.parent.remove(this.element.nativeElement);
        }
    }
    imageLoaded(image) {
        this.images.delete(image);
        if (this.images.size === 0) {
            this.renderer.setStyle(this.element.nativeElement, 'opacity', '100');
            this.parent.add(this.element.nativeElement);
            this.playAnimation(true);
        }
    }
    playAnimation(show) {
        const metadata = show ? this.animations.show : this.animations.hide;
        if (metadata) {
            const player = this.builder.build(metadata).create(this.element.nativeElement);
            player.play();
        }
    }
};
NgxMasonryDirective.ctorParameters = () => [
    { type: AnimationBuilder },
    { type: ElementRef },
    { type: NgxMasonryComponent, decorators: [{ type: Inject, args: [forwardRef(() => NgxMasonryComponent),] }] },
    { type: Renderer2 }
];
NgxMasonryDirective = __decorate([
    Directive({
        selector: '[ngxMasonryItem], ngxMasonryItem'
    }),
    __param(2, Inject(forwardRef(() => NgxMasonryComponent)))
], NgxMasonryDirective);

let NgxMasonryModule = class NgxMasonryModule {
};
NgxMasonryModule = __decorate([
    NgModule({
        imports: [],
        declarations: [NgxMasonryComponent, NgxMasonryDirective],
        exports: [NgxMasonryComponent, NgxMasonryDirective]
    })
], NgxMasonryModule);

/*
 * Public API Surface of ngx-masonry
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxMasonryComponent, NgxMasonryDirective, NgxMasonryModule };
//# sourceMappingURL=ngx-masonry.js.map
