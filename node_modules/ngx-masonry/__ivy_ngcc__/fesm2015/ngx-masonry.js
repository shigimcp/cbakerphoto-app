import masonryLayout from 'masonry-layout';
import { __decorate, __param } from 'tslib';
import { EventEmitter, Inject, PLATFORM_ID, ElementRef, Input, Output, Component, forwardRef, Renderer2, Directive, NgModule } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { style, animate, AnimationBuilder } from '@angular/animations';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/animations';

const _c0 = ["ngx-masonry", ""];
const _c1 = ["*"];
let masonryConstructor;
let NgxMasonryComponent = class NgxMasonryComponent {
    constructor(platformId, _element) {
        this.platformId = platformId;
        this._element = _element;
        this.updateLayout = false;
        // Outputs
        this.layoutComplete = new EventEmitter();
        this.removeComplete = new EventEmitter();
    }
    ngOnInit() {
        if (isPlatformBrowser(this.platformId) && masonryConstructor === undefined) {
            masonryConstructor = masonryLayout;
        }
        // Create masonry options object
        if (!this.options) {
            this.options = {};
        }
        // Set default itemSelector
        if (!this.options.itemSelector) {
            this.options.itemSelector = '[ngxMasonryItem], ngxMasonryItem';
        }
        this.options['transitionDuration'] = '0s';
        if (isPlatformBrowser(this.platformId)) {
            // Initialize Masonry
            this.masonryInstance = new masonryConstructor(this._element.nativeElement, this.options);
            // Bind to events
            this.masonryInstance.on('layoutComplete', (items) => {
                this.layoutComplete.emit(items);
            });
            this.masonryInstance.on('removeComplete', (items) => {
                this.removeComplete.emit(items);
            });
        }
    }
    ngOnChanges(changes) {
        // only update layout if it's not the first change
        if (changes.updateLayout) {
            if (!changes.updateLayout.firstChange) {
                this.layout();
            }
        }
    }
    ngOnDestroy() {
        if (this.masonryInstance) {
            this.masonryInstance.destroy();
        }
    }
    layout() {
        setTimeout(() => {
            this.masonryInstance.layout();
        });
    }
    reloadItems() {
        setTimeout(() => {
            this.masonryInstance.reloadItems();
        });
    }
    // public add(element: HTMLElement, prepend: boolean = false) {
    add(element) {
        // Tell Masonry that a child element has been added
        this.masonryInstance.appended(element);
        // Check if first item
        if (this.masonryInstance.items.length === 1) {
            this.masonryInstance.layout();
        }
    }
    remove(element) {
        // Tell Masonry that a child element has been removed
        this.masonryInstance.remove(element);
        // Layout items
        this.layout();
    }
};
NgxMasonryComponent.ɵfac = function NgxMasonryComponent_Factory(t) { return new (t || NgxMasonryComponent)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxMasonryComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxMasonryComponent, selectors: [["", "ngx-masonry", ""], ["ngx-masonry"]], inputs: { updateLayout: "updateLayout", options: "options" }, outputs: { layoutComplete: "layoutComplete", removeComplete: "removeComplete" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, ngContentSelectors: _c1, decls: 1, vars: 0, template: function NgxMasonryComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] {\n\t\t\tdisplay: block;\n\t\t}"] });
NgxMasonryComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: ElementRef }
];
__decorate([
    Input()
], NgxMasonryComponent.prototype, "options", void 0);
__decorate([
    Input()
], NgxMasonryComponent.prototype, "updateLayout", void 0);
__decorate([
    Output()
], NgxMasonryComponent.prototype, "layoutComplete", void 0);
__decorate([
    Output()
], NgxMasonryComponent.prototype, "removeComplete", void 0);
NgxMasonryComponent = __decorate([ __param(0, Inject(PLATFORM_ID))
], NgxMasonryComponent);

let NgxMasonryDirective = class NgxMasonryDirective {
    constructor(builder, element, parent, renderer) {
        this.builder = builder;
        this.element = element;
        this.parent = parent;
        this.renderer = renderer;
        this.animations = {
            show: [
                style({ opacity: 0 }),
                animate('400ms ease-in', style({ opacity: 1 })),
            ],
            hide: [
                style({ opacity: '*' }),
                animate('400ms ease-in', style({ opacity: 0 })),
            ]
        };
    }
    ngOnInit() {
        if (this.parent.options.animations !== undefined) {
            this.animations = this.parent.options.animations;
        }
    }
    ngAfterViewInit() {
        const images = this.element.nativeElement.getElementsByTagName('img');
        this.renderer.setStyle(this.element.nativeElement, 'opacity', '0');
        this.images = new Set(images);
        if (images.length === 0) {
            this.parent.add(this.element.nativeElement);
        }
        else {
            for (const imageRef of images) {
                this.renderer.listen(imageRef, 'load', _ => {
                    this.imageLoaded(imageRef);
                });
                this.renderer.listen(imageRef, 'error', _ => {
                    this.imageLoaded(imageRef);
                });
            }
        }
    }
    ngOnDestroy() {
        if (this.images.size === 0 && this.element.nativeElement.parentNode) {
            this.playAnimation(false);
            this.parent.remove(this.element.nativeElement);
        }
    }
    imageLoaded(image) {
        this.images.delete(image);
        if (this.images.size === 0) {
            this.renderer.setStyle(this.element.nativeElement, 'opacity', '100');
            this.parent.add(this.element.nativeElement);
            this.playAnimation(true);
        }
    }
    playAnimation(show) {
        const metadata = show ? this.animations.show : this.animations.hide;
        if (metadata) {
            const player = this.builder.build(metadata).create(this.element.nativeElement);
            player.play();
        }
    }
};
NgxMasonryDirective.ɵfac = function NgxMasonryDirective_Factory(t) { return new (t || NgxMasonryDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(forwardRef(() => NgxMasonryComponent)), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NgxMasonryDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxMasonryDirective, selectors: [["", "ngxMasonryItem", ""], ["ngxMasonryItem"]] });
NgxMasonryDirective.ctorParameters = () => [
    { type: AnimationBuilder },
    { type: ElementRef },
    { type: NgxMasonryComponent, decorators: [{ type: Inject, args: [forwardRef(() => NgxMasonryComponent),] }] },
    { type: Renderer2 }
];
NgxMasonryDirective = __decorate([ __param(2, Inject(forwardRef(() => NgxMasonryComponent)))
], NgxMasonryDirective);

let NgxMasonryModule = class NgxMasonryModule {
};
NgxMasonryModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxMasonryModule });
NgxMasonryModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxMasonryModule_Factory(t) { return new (t || NgxMasonryModule)(); }, imports: [[]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMasonryComponent, [{
        type: Component,
        args: [{
                selector: '[ngx-masonry], ngx-masonry',
                template: '<ng-content></ng-content>',
                styles: [`
		:host {
			display: block;
		}
	`]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: ɵngcc0.ElementRef }]; }, { updateLayout: [{
            type: Input
        }], layoutComplete: [{
            type: Output
        }], removeComplete: [{
            type: Output
        }], options: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMasonryDirective, [{
        type: Directive,
        args: [{
                selector: '[ngxMasonryItem], ngxMasonryItem'
            }]
    }], function () { return [{ type: ɵngcc1.AnimationBuilder }, { type: ɵngcc0.ElementRef }, { type: NgxMasonryComponent, decorators: [{
                type: Inject,
                args: [forwardRef(() => NgxMasonryComponent)]
            }] }, { type: ɵngcc0.Renderer2 }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxMasonryModule, { declarations: [NgxMasonryComponent,
        NgxMasonryDirective], exports: [NgxMasonryComponent,
        NgxMasonryDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxMasonryModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [NgxMasonryComponent, NgxMasonryDirective],
                exports: [NgxMasonryComponent, NgxMasonryDirective]
            }]
    }], null, null); })();

/*
 * Public API Surface of ngx-masonry
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxMasonryComponent, NgxMasonryDirective, NgxMasonryModule };

//# sourceMappingURL=ngx-masonry.js.map